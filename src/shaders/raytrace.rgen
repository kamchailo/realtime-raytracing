#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64  : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "shared_structs.h"
#include "rng.glsl"

#include "raytraceBrdf.glsl"

// The ray payload, attached to a ray; used to communicate between shader stages.
layout(location=0) rayPayloadEXT RayPayload payload;

// Push constant for ray tracing shaders
layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };

// Ray tracing descriptor set: 0:acceleration structure, and 1: color output image
layout(set=0, binding=0) uniform accelerationStructureEXT topLevelAS;
layout(set=0, binding=1, rgba32f) uniform image2D colCurr; // Output image: m_rtColCurrBuffer
layout(set=0, binding=2, rgba32f) uniform image2D colPrev; // Output image: m_rtColPrevBuffer
layout(set=0, binding=3, rgba32f) uniform image2D kdCurr; // Output image: m_rtKdCurrBuffer
layout(set=0, binding=4, rgba32f) uniform image2D kdPrev; // Output image: m_rtKdPrevBuffer
layout(set=0, binding=5, rgba32f) uniform image2D ndCurr; // Output image: m_rtNdCurrBuffer
layout(set=0, binding=6, rgba32f) uniform image2D ndPrev; // Output image: m_rtNdPrevBuffer


// Object model descriptor set: 0: matrices, 1:object buffer addresses, 2: texture list
layout(set=1, binding=0) uniform _MatrixUniforms { MatrixUniforms mats; };
layout(set=1, binding=1, scalar) buffer ObjDesc_ { ObjDesc i[]; } objDesc;
layout(set=1, binding=2) uniform sampler2D textureSamplers[];

// Object buffered data; dereferenced from ObjDesc addresses
layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Position, normals, ..
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices
layout(buffer_reference, scalar) buffer Materials {Material m[]; }; // Array of all materials
layout(buffer_reference, scalar) buffer MatIndices {int i[]; }; // Material ID for each triangle


void main() 
{
    // Check for Push Constant alignment
    if(pcRay.alignmentTest != 1234)
    {
        imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(1.0, 0.2, 0.2, 0.0));
        // C = vec3(pcRay.tempLightInt.w);
        return;
    }


    // This invocation is for a pixel indicated by gl_LaunchIDEXT
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    vec2 pixelNDC = pixelCenter/vec2(gl_LaunchSizeEXT.xy)*2.0 - 1.0;
 
    vec3 eyeW    = (mats.viewInverse * vec4(0, 0, 0, 1)).xyz;
    vec4 pixelH = mats.viewInverse * mats.projInverse * vec4(pixelNDC.x, pixelNDC.y, 1, 1);
    vec3 pixelW = pixelH.xyz/pixelH.w;
    
    vec3 rayOrigin    = eyeW;
    vec3 rayDirection = normalize(pixelW - eyeW);

    // Declare deref variable
    vec3 bc;
    vec3 nrm;
    vec2 uv;

    // Declare BRDF variable
    vec3 P;
    vec3 N;
    vec3 Wi;
    vec3 Wo;

    // Path tracing -- Monte-Carlo
    payload.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pcRay.frameSeed);
    // C = Pixel color, accumulated color along the path; output at the end
    vec3 C = vec3(0.0, 0.0, 0.0); 
    // W = Accumulation of f/p weights along path; multiplied by light
    vec3 W = vec3(1.0, 1.0, 1.0);

    // History Accumulation
    bool firstHit;
    float firstDepth;
    vec3 firstNormal;
    vec4 firstKd;
    vec3 firstPos;

    // Loop through ray-by-ray along a path
    for( int i =0; i < pcRay.depth; ++i)
    {
        // Fire the ray;  hit or miss shaders will be invoked, passing results back in the payload
        traceRayEXT(topLevelAS,           // acceleration structure
                    gl_RayFlagsOpaqueEXT, // rayFlags
                    0xFF,                 // cullMask
                    0,                    // sbtRecordOffset for the hitgroups
                    0,                    // sbtRecordStride for the hitgroups
                    0,                    // missIndex
                    rayOrigin,            // ray origin
                    0.001,                // ray min range
                    rayDirection,         // ray direction
                    10000.0,              // ray max range
                    0                     // payload (location = 0)
                    );

        if (!payload.hit) 
        {
            break;
        }


        // Dereference objDesc, calc vertices, mat, nrm, uv; read texture
        // If something was hit, find the object data.
        // Object data (containg 4 device addresses)
        ObjDesc    objResources = objDesc.i[payload.instanceIndex];
    
        // Dereference the object's 4 device addresses
        Vertices   vertices    = Vertices(objResources.vertexAddress);
        Indices    indices     = Indices(objResources.indexAddress);
        Materials  materials   = Materials(objResources.materialAddress);
        MatIndices matIndices  = MatIndices(objResources.materialIndexAddress);
  
        // Use gl_PrimitiveID to access the triangle's vertices and material
        ivec3 ind    = indices.i[payload.primitiveIndex]; // The triangle hit
        int matIdx   = matIndices.i[payload.primitiveIndex]; // The triangles material index
        Material mat = materials.m[matIdx]; // The triangles material

        // Vertex of the triangle (Vertex has pos, nrm, tex)
        Vertex v0 = vertices.v[ind.x];
        Vertex v1 = vertices.v[ind.y];
        Vertex v2 = vertices.v[ind.z];

        // Computing the normal and tex coord at hit position
        vec3 bc = payload.bc; // The barycentric coordinates of the hit point
        vec3 nrm  = bc.x*v0.nrm      + bc.y*v1.nrm      + bc.z*v2.nrm;
        vec2 uv =  bc.x*v0.texCoord + bc.y*v1.texCoord + bc.z*v2.texCoord;

        // If the material has a texture, read diffuse color from it.
        if (mat.textureId >= 0) {
            uint txtId = objResources.txtOffset + mat.textureId;
            mat.diffuse = texture(textureSamplers[(txtId)], uv).xyz;
        }

        // First hit
        if( i == 0 )
        {
            firstHit = payload.hit;
            firstDepth = payload.hitDist;
            firstNormal = nrm;
            firstKd = vec4(mat.diffuse, 1);
            firstPos = payload.hitPos;
        }

        // If material indicates triangle is a light, accumulate the light value.
        if (dot(mat.emission, mat.emission) > 0.0) 
        {
            C += mat.emission * 0.5 * W;
            break;
            // imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(mat.emission,1.0));
            // return; 
        }


        // @@ FUTURE EXPLICIT light

        // From the current hit point, setup N,L,V for BRDF calculation
        //   P = Current Hit Point
        //   Normal N from nrm above 
        //   Light direction L from pcRay.tempLightPos - payload.hitPos
        //   View direction V is the reverse of rayDirection
        //   Light values from pcRay
        //   Material properties from mat (above), possibly modified by a texture
        P = payload.hitPos;
        N = normalize(nrm);

        // Wi and Wo play the same role as L and V, in most presentations of BRDF
        // … but makes more sense then L and V notation in the middle of a long path
        Wi = SampleBrdf(payload.seed, N);  // Importance sample output direction
        Wo = -rayDirection;

        vec3 f = EvalBrdf(N, Wi, Wo, mat);      // Color (vec3) according to BRDF
        float p = PdfBrdf(N, Wi) * pcRay.rr;    // Probability (float) of above sample of Wi

        const float epsilon = 1e-6;         // 10^-6
        if(p < epsilon)                         // epsilon = 10^-6; Mathematically impossible, but due to roundoff ...
        {
            break;
        }

        W *= f / p; // Monte-Carlo estimator

        // Step forward for next loop iteration
        rayOrigin = payload.hitPos;
        rayDirection = Wi;

    }
    
    // Accumulate (or not) C into output image
    /*
    if(pcRay.clear)
    {
        imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(C, 1.0));
    }
    else
    {
        vec4 old = imageLoad(colCurr, ivec2(gl_LaunchIDEXT.xy));
        vec3 Ave = old.xyz;         // Existing average color
        float newN = old.w + 1.0;         // Existing count
        Ave += (C - Ave) / newN;
        //imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(C, N + 1.0));
        if( !any(isnan(Ave)) && !any(isinf(Ave)) )
        {
            imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(Ave, newN));
        }
    }
    */

    // New History Accumulation
    //vec4 old = imageLoad(colCurr, ivec2(gl_LaunchIDEXT.xy)); 
    // change to not just load previous but check if it need new value
    // - change of normal > threashold
    // - change of depth > threashold
    // - Out of previoys frame

    // Get previous frame screen position 
    vec4 screenH = (mats.priorViewProj * vec4(firstPos, 1.0)); // project to previous buffer
    vec2 screen = ((screenH.xy / screenH.w) + vec2(1.0)) / 2.0; // H-division and map to [0,1]
    
    // Calculate Previous
    vec4 previous = vec4(0.0); // P
    vec4 previousFragments[2][2];

    //  _________________
    //  |       |       |
    //  |  iloc | iloc  |
    //  |  0,1  | 1,1   |
    //  |_______|_______|
    //  |       | x     | _  <<---- x = floc
    //  |  iloc | iloc  |  | offset.y
    //  |  0,0  | 1,0   | _|
    //  |_______|_______|  
    //      |_____|      
    //         offset.x

    vec2 floc = screen * gl_LaunchSizeEXT.xy - vec2(0.5);
    vec2 offset = fract(floc); // 0 - 1 offset between 4 neighbots.
    ivec2 iloc = ivec2(floc); // (0, 0) is left bottom of the 4 neighbors.

    // Calculate weight // weight = bilinear * selective (0 or 1)
    float w[2][2];
    // Calculate Bilinear
    float b[2][2];
    b[0][0] = ( 1.0 - offset.x ) * ( 1.0 - offset.y ); // 1.0 from max weight
    b[1][0] = (       offset.x ) * ( 1.0 - offset.y );
    b[0][1] = ( 1.0 - offset.x ) * (       offset.y );
    b[1][1] = (       offset.x ) * (       offset.y );
    
    vec3 prevNormal;
    float prevDepth;

    // Calculate Selective
    //int s[2][2];
    float sumDenominator = 0.0;
    for(int i = 0; i < 2; ++i)
    {
        for(int j = 0; j < 2; ++j)
        {
            // load old image
            w[i][j] = 0;
            previousFragments[i][j] = vec4(0.0);
            vec4 oldNd = imageLoad(ndPrev, iloc + ivec2(i,j));
            prevNormal = oldNd.xyz; //i,j = 0,0 - 1,1 
            prevDepth = oldNd.w;

            if( dot(firstNormal, prevNormal) > pcRay.n_threshold
                && abs(firstDepth - prevDepth) < pcRay.d_threshold)
            {
                //s[i][j] = 1;
                w[i][j] = b[i][j];
                previousFragments[i][j] = imageLoad(colPrev, iloc + ivec2(i,j));
                previous += previousFragments[i][j] * w[i][j];
                sumDenominator += w[i][j];
            }
            else
            {
                //s[i][j] = 0;
                w[i][j] = 0;
            }
        }
    }

    previous /= sumDenominator;
    

    float oldN = previous.w; // Beware: this will not be an integer anymore. This is not a problem!
    vec3 oldAve = previous.xyz;

    if( !firstHit
        || screen.x < 0.0 || screen.x > 1.0
        || screen.y < 0.0 || screen.y > 1.0)
    {
        oldN = 1.0;
        oldAve = vec3(0.3);
    }

    float newN = oldN + 1.0;
    vec3 newAve = oldAve + (C - oldAve) / newN;


    if( !any(isnan(newAve)) && !any(isinf(newAve)) )
    {
        imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(newAve, newN));
    }
    else
    {
        //imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(oldAve, oldN));
    }


    if( !any(isnan(firstKd)) && !any(isinf(firstKd)) )
    {
        imageStore(kdCurr, ivec2(gl_LaunchIDEXT.xy), firstKd);
    }

    if( !any(isnan(firstNormal)) && !any(isinf(firstNormal)) && !isnan(firstDepth) && !isinf(firstDepth))
    {
        imageStore(ndCurr, ivec2(gl_LaunchIDEXT.xy), vec4(firstNormal,firstDepth));
    }

    // Debug
    /*
    */
    //imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(prevNormal, 1.0));
    if(!firstHit)
    {
        imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(vec3(0.2,0.1,0.1), 1.0));
    }
}
